use std::str::FromStr;
use lalrpop_util::ParseError;
use lalrpop_util::ErrorRecovery;
use crate::ast::*;

grammar<'err>(errors: &'err mut Vec<ErrorRecovery<usize, Token<'input>, AstError>>);

extern {
	type Error = AstError;
}

Delimit<T, S>: Vec<T> = {
	<mut v:(<T> S)*> <e:T?> => {
		if let Some(e) = e {
			v.push(e);
		}
		v
	}
};

Tier<Op,NextTier>: Node = {
	<lhs:Tier<Op,NextTier>> <op:Op> <rhs:NextTier> => Node::BinOp(BinOp { lhs: Box::new(lhs), op, rhs: Box::new(rhs) }),
	NextTier
};

pub Top: Node = {
	<stmts:Body> => Node::Block(Block { <> }),
};
Body = Delimit<Stmt, ";">;
Stmt: Node = {
	Let => Node::Let(<>),
	Block => Node::Block(<>),
	Loop => Node::Loop(<>),
	While => Node::While(<>),
	For => Node::For(<>),
	IfElse => Node::IfElse(<>),
	"unreachable" => Node::Unreachable,
	Continue,
	Break => Node::Break(<>),
	Ret => Node::Return(<>),
};
Let: Let = {
	"let" <bind:Pat> "=" <expr:Expr> => Let { bind: Box::new(bind), expr: Box::new(expr) },
}
Block: Block = "{" <stmts:Body> "}" => Block { <> };
Loop: Loop = {
	"loop" <body:Expr> => Loop { body: Box::new(body) },
};
While: While = {
	"while" <cond:Expr> <body:Block> => While { cond: Box::new(cond), body: Box::new(Node::Block(body)) },
	"while" <cond:Expr> ":" <body:Expr> => While { cond: Box::new(cond), body: Box::new(body) },
};
For: For = {
	"for" <bind:Pat> "in" <iter:Expr> <body:Block> => For { bind: Box::new(bind), iter: Box::new(iter), body: Box::new(Node::Block(body)) },
	"for" <bind:Pat> "in" <iter:Expr> ":" <body:Expr> => For { bind: Box::new(bind), iter: Box::new(iter), body: Box::new(body) },
};
IfElse: IfElse = {
	"if" <cond:Expr> <body_if:Block> <body_else:("else" <Expr>)?> => IfElse { cond: Box::new(cond), body_if: Box::new(Node::Block(body_if)), body_else: body_else.map(|body_else| Box::new(body_else)) },
	"if" <cond:Expr> ":" <body_if:Expr> <body_else:("else" <Expr>)?> => IfElse {cond: Box::new(cond), body_if: Box::new(body_if), body_else: body_else.map(|body_else| Box::new(body_else)) },
};
Continue: Node = "continue" => Node::Continue;
Break: Break = {
	"break" <expr:Expr?> => Break { expr: expr.map(|expr| Box::new(expr)) },
	"break" <expr:Continue> => Break { expr: Some(Box::new(<>)) },
}
Ret: Return = {
	"ret" <expr:Expr?> => Return { expr: expr.map(|expr| Box::new(expr)) },
}
Pat: Node = {
	Ident => Node::Literal(Literal::Identifier(<>)),
};

Expr = Tier<BinOp0, Factor>;
Factor = Tier<BinOp1, Term>;

//BinOpLogic: BinOpKind = {
//	"&&" => BinOpKind::(ArithBinOpKind::And),
//	"||" => BinOpKind::Arith(ArithBinOpKind::Or),
//};

BinOp0: BinOpKind = {
	"+" => BinOpKind::Arith(ArithBinOpKind::Add),
	"-" => BinOpKind::Arith(ArithBinOpKind::Sub),
};

BinOp1: BinOpKind = {
	"*" => BinOpKind::Arith(ArithBinOpKind::Mul),
	"/" => BinOpKind::Arith(ArithBinOpKind::Div),
};

UnaOp: UnaOpKind = {
	"+" => UnaOpKind::Identity,
	"-" => UnaOpKind::Negate,
};

Term: Node = {
	Atom,
	<op:UnaOp> <expr:Term> => Node::UnaOp(UnaOp { op, expr: Box::new(expr) }),
};
Atom: Node = {
	Lit => Node::Literal(<>),
	"(" <Expr> ")",
	//! => { errors.push(<>); Node::Error },
};

Lit: Literal = {
	Int => Literal::Integer(<>),
	// Float => Literal::Float(<>),
	// String => Literal::String(<>),
	Ident => Literal::Identifier(<>),
};

Int: u64 = r"[0-9]+" =>? u64::from_str(<>).map_err(|e| ParseError::User {
	error: AstError::BadNumber(e)
});

Ident: String = r"[\p{XID_Start}_]\p{XID_Continue}*" => <>.to_string();

//extern {
//	type Location = usize;
//	type Error = LexicalError;
//
//	enum Token {
//		// keywords
//		"let" => Token::KeywordLet,
//		"fn" => Token::KeywordFn,
//		"ret" => Token::KeywordReturn,
//		"struct" => Token::KeywordStruct,
//		"if" => Token::KeywordIf,
//		"else" => Token::KeywordElse,
//		"while" => Token::KeywordWhile,
//		"for" => Token::KeywordFor,
//		"match" => Token::KeywordMatch,
//		"pub" => Token::KeywordPub,
//		"mut" => Token::KeywordMut,
//
//		// literals
//		"identifier" => Token::Identifier(<String>),
//		"integer" => Token::Integer(<u128>),
//		"string" => Token::String(<String>),
//
//		"(" => Token::LeftParen,
//		")" => Token::RightParen,
//		"{" => Token::LeftBracket,
//		"}" => Token::RightBracket,
//		"[" => Token::LeftSquareBracket,
//		"]" => Token::RightSquareBracket,
//		"=" => Token::Assign,
//		";" => Token::Semicolon,
//		":" => Token::Colon,
//		"," => Token::Coma,
//		"." => Token::Dot,
//		"<" => Token::LessThanSign,
//		">" => Token::MoreThanSign,
//		">=" => Token::MoreThanEqSign,
//		"<=" => Token::LessThanEqSign,
//
//		// operators
//		"+" => Token::OperatorAdd,
//		"-" => Token::OperatorSub,
//		"*" => Token::OperatorMul,
//		"/" => Token::OperatorDiv,
//		"%" => Token::OperatorRem,
//		"&&" => Token::OperatorAnd,
//		"||" => Token::OperatorOr,
//		"==" => Token::OperatorEq,
//		"!=" => Token::OperatorNe,
//		"!" => Token::OperatorNot,
//	}
//}
