use lalrpop_util::ErrorRecovery;
use crate::lexer::{Token, LexicalError};
use crate::parser::*;

grammar<'err>(errors: &'err mut Vec<ErrorRecovery<usize, Token, AstError>>);

Delimit0<T, S>: Vec<T> = {
	<mut v:(<T> S)*> <e:T?> => {
		if let Some(e) = e {
			v.push(e);
		}
		v
	}
};

Delimit1<T, S>: Vec<T> = {
	<mut v:(<T> S)+> <e:T?> => {
		if let Some(e) = e {
			v.push(e);
		}
		v
	}
};

Tier<Op,NextTier>: Expr = {
	<lhs:Tier<Op,NextTier>> <op:Op> <rhs:NextTier> => Expr::BinOp(BinOp { lhs: Box::new(lhs), op, rhs: Box::new(rhs) }),
	NextTier
};

pub Top: Expr = {
	<stmts:Stmt*> => Expr::Block(Block { <>, expr: None }),
};
SimpleStmt: Expr = {
	<Assign> ";" => Expr::Assign(<>),
	<Ret> ";" => Expr::Return(<>),
	<Break> ";" => Expr::Break(<>),
	<Continue> ";",
};
Stmt: Expr = {
	SimpleStmt,
	Block => Expr::Block(<>),
	Loop<Stmt> => Expr::Loop(<>),
	While => Expr::While(<>),
	For => Expr::For(<>),
	If => Expr::If(<>),
};
StmtElse: Expr = {
	SimpleStmt,
	BlockExpr => Expr::Block(<>),
	Loop<StmtElse> => Expr::Loop(<>),
	WhileElse<StmtElse, Block, StmtElse> => Expr::While(<>),
	ForElse<StmtElse, Block, StmtElse> => Expr::For(<>),
	IfElse<StmtElse, Block, StmtElse> => Expr::If(<>),
};
Atom: Expr = {
	"identifier" => Expr::Identifier(<>),
	"string" => Expr::StrLit(<>),
	"integer" => Expr::IntLit(<>),
	//"real" => Expr::Real(<>),
	BlockExpr => Expr::Block(<>),
	"(" <Expr> ")",
	"(" ")" => Expr::TupleCtor(TupleCtor { items: Vec::new() }),
	"(" <items:Delimit1<Expr, ",">> ")" => Expr::TupleCtor(TupleCtor { <> }),
	Unreachable,
};
Expr: Expr = {
	#[precedence(level="0")] Atom,
	#[precedence(level="1")] #[assoc(side="left")] <op:UnaOp> <expr:Expr> => Expr::UnaOp(UnaOp { op, expr: Box::new(expr) }),
	#[precedence(level="2")] #[assoc(side="left")] <lhs:Expr> <op:BinOp0> <rhs:Expr> => Expr::BinOp(BinOp { lhs: Box::new(lhs), op, rhs: Box::new(rhs) }),
	#[precedence(level="3")] #[assoc(side="left")] <lhs:Expr> <op:BinOp1> <rhs:Expr> => Expr::BinOp(BinOp { lhs: Box::new(lhs), op, rhs: Box::new(rhs) }),
	#[precedence(level="4")] #[assoc(side="left")] <lhs:Expr> <op:BinOp2> <rhs:Expr> => Expr::BinOp(BinOp { lhs: Box::new(lhs), op, rhs: Box::new(rhs) }),
	#[precedence(level="5")] #[assoc(side="left")] <lhs:Expr> <op:BinOp3> <rhs:Expr> => Expr::BinOp(BinOp { lhs: Box::new(lhs), op, rhs: Box::new(rhs) }),
	#[precedence(level="6")] #[assoc(side="left")] <lhs:Expr> <op:BinOp4> <rhs:Expr> => Expr::BinOp(BinOp { lhs: Box::new(lhs), op, rhs: Box::new(rhs) }),
	#[precedence(level="7")]
	Loop<Stmt> => Expr::Loop(<>),
	WhileElse<ExprElse, BlockExpr, Expr> => Expr::While(<>),
	ForElse<ExprElse, BlockExpr, Expr> => Expr::For(<>),
	IfElse<ExprElse, BlockExpr, Expr> => Expr::If(<>),
};
ExprElse: Expr = {
	#[precedence(level="0")] Atom,
	#[precedence(level="1")] #[assoc(side="left")] <op:UnaOp> <expr:ExprElse> => Expr::UnaOp(UnaOp { op, expr: Box::new(expr) }),
	#[precedence(level="2")] #[assoc(side="left")] <lhs:ExprElse> <op:BinOp0> <rhs:ExprElse> => Expr::BinOp(BinOp { lhs: Box::new(lhs), op, rhs: Box::new(rhs) }),
	#[precedence(level="3")] #[assoc(side="left")] <lhs:ExprElse> <op:BinOp1> <rhs:ExprElse> => Expr::BinOp(BinOp { lhs: Box::new(lhs), op, rhs: Box::new(rhs) }),
	#[precedence(level="4")] #[assoc(side="left")] <lhs:ExprElse> <op:BinOp2> <rhs:ExprElse> => Expr::BinOp(BinOp { lhs: Box::new(lhs), op, rhs: Box::new(rhs) }),
	#[precedence(level="5")] #[assoc(side="left")] <lhs:ExprElse> <op:BinOp3> <rhs:ExprElse> => Expr::BinOp(BinOp { lhs: Box::new(lhs), op, rhs: Box::new(rhs) }),
	#[precedence(level="6")] #[assoc(side="left")] <lhs:ExprElse> <op:BinOp4> <rhs:ExprElse> => Expr::BinOp(BinOp { lhs: Box::new(lhs), op, rhs: Box::new(rhs) }),
	#[precedence(level="7")]
	Loop<StmtElse> => Expr::Loop(<>),
	WhileElse<ExprElse, BlockExpr, ExprElse> => Expr::While(<>),
	ForElse<ExprElse, BlockExpr, ExprElse> => Expr::For(<>),
	IfElse<ExprElse, BlockExpr, ExprElse> => Expr::If(<>),
};

UnaOp: UnaOpKind = {
	"+" => UnaOpKind::Identity,
	"-" => UnaOpKind::Negate,
	"!" => UnaOpKind::Not,
};
BinOp0: BinOpKind = {
	"*" => BinOpKind::Arith(ArithBinOp { kind: ArithBinOpKind::Mul, allow_wrap: false }),
	"/" => BinOpKind::Arith(ArithBinOp { kind: ArithBinOpKind::Div, allow_wrap: false }),
};
BinOp1: BinOpKind = {
	"+" => BinOpKind::Arith(ArithBinOp { kind: ArithBinOpKind::Add, allow_wrap: false }),
	"-" => BinOpKind::Arith(ArithBinOp { kind: ArithBinOpKind::Sub, allow_wrap: false }),
};
BinOp2: BinOpKind = {
	"==" => BinOpKind::Cmp(CmpBinOpKind::Eq),
	"!=" => BinOpKind::Cmp(CmpBinOpKind::Ne),
	"<" => BinOpKind::Cmp(CmpBinOpKind::Lt),
	"<=" => BinOpKind::Cmp(CmpBinOpKind::Le),
	">" => BinOpKind::Cmp(CmpBinOpKind::Gt),
	">=" => BinOpKind::Cmp(CmpBinOpKind::Ge),
}
BinOp3: BinOpKind = {
	"&&" => BinOpKind::Logic(LogicBinOpKind::And),
};
BinOp4: BinOpKind = {
	"||" => BinOpKind::Logic(LogicBinOpKind::Or),
}

Block: Block = "{" <stmts:Stmt*> "}" => Block { stmts, expr: None };
BlockExpr: Block = "{" <stmts:Stmt*> "||" <expr:Expr> "}" => Block { stmts, expr: Some(Box::new(expr)) };
Assign: Assign = <lhs:Pat> "=" <rhs:Expr> => Assign { op: None, lhs: Box::new(lhs), rhs: Box::new(rhs) };
Ret: Return = {
	"ret" <expr:Expr?> => Return { expr: expr.map(|expr| Box::new(expr)) },
};
Break: Break = {
	"break" <expr:Expr?> => Break { expr: expr.map(|expr| Box::new(expr)) },
	"break" <Continue> => Break { expr: Some(Box::new(<>)) },
	"break" <Break> => Break { expr: Some(Box::new(Expr::Break(<>))) },
};
Continue: Expr = "continue" => Expr::Continue;
Unreachable: Expr = "unreachable" => Expr::Unreachable;

Loop<TBody>: Loop = {
	"loop" <body:TBody> => Loop { body: Box::new(body) },
};

While: While = {
	"while" <cond:Expr> <body:Block> => While {
		cond: Box::new(cond),
		body: Box::new(Expr::Block(body)),
		body_else: None,
	},
	"while" <cond:Expr> ":" <body:Stmt> => While {
		cond: Box::new(cond),
		body: Box::new(body),
		body_else: None,
	},
	WhileElse<StmtElse, Block, Stmt>,
};
WhileElse<TBody, TBlock, TElse>: While = {
	"while" <cond:Expr> <body:TBlock> "else" <body_else:TElse> => While {
		cond: Box::new(cond),
		body: Box::new(Expr::Block(body)),
		body_else: Some(Box::new(body_else)),
	},
	"while" <cond:Expr> ":" <body:TBody> "else" <body_else:TElse> => While {
		cond: Box::new(cond),
		body: Box::new(body),
		body_else: Some(Box::new(body_else)),
	},
};

For: For = {
	"for" <binding:Pat> "in" <iter:Expr> <body:Block> => For {
		binding: Box::new(binding),
		iter: Box::new(iter),
		body: Box::new(Expr::Block(body)),
		body_else: None,
	},
	"for" <binding:Pat> "in" <iter:Expr> ":" <body:Stmt> => For {
		binding: Box::new(binding),
		iter: Box::new(iter),
		body: Box::new(body),
		body_else: None,
	},
	ForElse<StmtElse, Block, Stmt>,
};
ForElse<TBody, TBlock, TElse>: For = {
	"for" <binding:Pat> "in" <iter:Expr> <body:TBlock> "else" <body_else:TElse> => For {
		binding: Box::new(binding),
		iter: Box::new(iter),
		body: Box::new(Expr::Block(body)),
		body_else: Some(Box::new(body_else)),
	},
	"for" <binding:Pat> "in" <iter:Expr> ":" <body:TBody> "else" <body_else:TElse> => For {
		binding: Box::new(binding),
		iter: Box::new(iter),
		body: Box::new(body),
		body_else: Some(Box::new(body_else)),
	},
};

If: If = {
	"if" <cond:Expr> <body:Block> => If {
		cond: Box::new(cond),
		body: Box::new(Expr::Block(body)),
		body_else: None,
	},
	"if" <cond:Expr> ":" <body:Stmt> => If {
		cond: Box::new(cond),
		body: Box::new(body),
		body_else: None,
	},
	IfElse<StmtElse, Block, Stmt>,
};
IfElse<TBody, TBlock, TElse>: If = {
	"if" <cond:Expr> <body:TBlock> "else" <body_else:TElse> => If {
		cond: Box::new(cond),
		body: Box::new(Expr::Block(body)),
		body_else: Some(Box::new(body_else)),
	},
	"if" <cond:Expr> ":" <body:TBody> "else" <body_else:TElse> => If {
		cond: Box::new(cond),
		body: Box::new(body),
		body_else: Some(Box::new(body_else)),
	},
};

Pat: Pattern = {
	"let" <Pat> => Pattern::Let(Let { pat: Box::new(<>) }),
	"mut" <Pat> => Pattern::Mut(Mut { pat: Box::new(<>) }),
	// <Expr> "*" => Pattern::Deref(Box::new(<>)),
	// Delimit0<Pat, ","> => Pattern::TupleDtor(TupleDtor { items: <> }),
	"identifier" => Pattern::Binding(<>),
	// "_" => Pattern::Discard,
};

extern {
	type Location = usize;
	type Error = LexicalError;

	enum Token {
		";" => Token::Semicolon,
		":" => Token::Colon,
		"," => Token::Comma,
		"." => Token::Dot,

		"(" => Token::LParen,
		")" => Token::RParen,
		"[" => Token::LBracket,
		"]" => Token::RBracket,
		"{" => Token::LBrace,
		"}" => Token::RBrace,

		"+" => Token::Plus,
		"-" => Token::Dash,
		"*" => Token::Star,
		"/" => Token::Slash,
		"%" => Token::Percent,
		"#" => Token::Hash,
		"<<" => Token::LShift,
		">>" => Token::RShift,
		"&" => Token::Ampersand,
		"|" => Token::Bar,

		"=" => Token::Equals,
		"==" => Token::Eq,
		"!=" => Token::Ne,
		"<" => Token::Lt,
		"<=" => Token::Le,
		">" => Token::Gt,
		">=" => Token::Ge,
		"&&" => Token::And,
		"||" => Token::Or,
		"!" => Token::Bang,

		"let" => Token::Let,
		"mut" => Token::Mut,
		"_" => Token::Discard,

		"ret" => Token::Return,
		"break" => Token::Break,
		"continue" => Token::Continue,
		"unreachable" => Token::Unreachable,

		"plex" => Token::Plex,
		"fn" => Token::Fn,
		"pub" => Token::Pub,

		"loop" => Token::Loop,
		"while" => Token::While,
		"for" => Token::For,
		"in" => Token::In,
		"if" => Token::If,
		"else" => Token::Else,
		"match" => Token::Match,

		"true" => Token::True,
		"false" => Token::False,
		"string" => Token::String(<String>),
		"integer" => Token::Integer(<u64>),
		"real" => Token::Real(<u64>),
		"identifier" => Token::Identifier(<String>),
	}
}
