use lalrpop_util::ErrorRecovery;
use crate::lexer::{Token, LexicalError};
use crate::parser::*;

grammar<'err>(errors: &'err mut Vec<ErrorRecovery<usize, Token, AstError>>);

Delimit0<T, S>: Vec<T> = {
	<mut v:(<T> S)*> <e:T?> => {
		if let Some(e) = e {
			v.push(e);
		}
		v
	}
};

Delimit1<T, S>: Vec<T> = {
	<mut v:(<T> S)+> <e:T?> => {
		if let Some(e) = e {
			v.push(e);
		}
		v
	}
};

Tier<Op,NextTier>: Node = {
	<lhs:Tier<Op,NextTier>> <op:Op> <rhs:NextTier> => Node::BinOp(BinOp { lhs: Box::new(lhs), op, rhs: Box::new(rhs) }),
	NextTier
};

pub Top: Node = {
	<body:Stmt*> => Node::Block(Block { <>, expr: None }),
};
SimpleStmt: Node = {
	<Let> ";" => Node::Let(<>),
	<Assign> ";" => Node::Assign(<>),
	<Ret> ";" => Node::Return(<>),
	<Break> ";" => Node::Break(<>),
	<Continue> ";",
};
Stmt: Node = {
	SimpleStmt,
	Block => Node::Block(<>),
	Loop<Stmt> => Node::Loop(<>),
	While => Node::While(<>),
	For => Node::For(<>),
	If => Node::IfElse(<>),
};
StmtElse: Node = {
	SimpleStmt,
	BlockExpr => Node::Block(<>),
	Loop<StmtElse> => Node::Loop(<>),
	WhileElse<StmtElse, Block, StmtElse> => Node::While(<>),
	ForElse<StmtElse, Block, StmtElse> => Node::For(<>),
	IfElse<StmtElse, Block, StmtElse> => Node::IfElse(<>),
};
Lit: Literal = {
	"identifier" => Literal::Identifier(<>),
	"string" => Literal::String(<>),
	"integer" => Literal::Integer(<>),
	"real" => Literal::Real(<>),
};
Atom: Node = {
	Lit => Node::Literal(<>),
	BlockExpr => Node::Block(<>),
	"(" <Expr> ")",
	"(" ")" => Node::TupleCtor(TupleCtor { items: Vec::new() }),
	"(" <items:Delimit1<Expr, ",">> ")" => Node::TupleCtor(TupleCtor { <> }),
	Unreachable,
};
Expr: Node = {
	#[precedence(level="0")] Atom,
	#[precedence(level="1")] #[assoc(side="left")] <op:UnaOp> <expr:Expr> => Node::UnaOp(UnaOp { op, expr: Box::new(expr) }),
	#[precedence(level="2")] #[assoc(side="left")] <lhs:Expr> <op:BinOp0> <rhs:Expr> => Node::BinOp(BinOp { lhs: Box::new(lhs), op, rhs: Box::new(rhs) }),
	#[precedence(level="3")] #[assoc(side="left")] <lhs:Expr> <op:BinOp1> <rhs:Expr> => Node::BinOp(BinOp { lhs: Box::new(lhs), op, rhs: Box::new(rhs) }),
	#[precedence(level="4")] #[assoc(side="left")] <lhs:Expr> <op:BinOp2> <rhs:Expr> => Node::BinOp(BinOp { lhs: Box::new(lhs), op, rhs: Box::new(rhs) }),
	#[precedence(level="5")] #[assoc(side="left")] <lhs:Expr> <op:BinOp3> <rhs:Expr> => Node::BinOp(BinOp { lhs: Box::new(lhs), op, rhs: Box::new(rhs) }),
	#[precedence(level="6")] #[assoc(side="left")] <lhs:Expr> <op:BinOp4> <rhs:Expr> => Node::BinOp(BinOp { lhs: Box::new(lhs), op, rhs: Box::new(rhs) }),
	#[precedence(level="7")]
	Loop<Stmt> => Node::Loop(<>),
	WhileElse<ExprElse, BlockExpr, Expr> => Node::While(<>),
	ForElse<ExprElse, BlockExpr, Expr> => Node::For(<>),
	IfElse<ExprElse, BlockExpr, Expr> => Node::IfElse(<>),
};
ExprElse: Node = {
	#[precedence(level="0")] Atom,
	#[precedence(level="1")] #[assoc(side="left")] <op:UnaOp> <expr:ExprElse> => Node::UnaOp(UnaOp { op, expr: Box::new(expr) }),
	#[precedence(level="2")] #[assoc(side="left")] <lhs:ExprElse> <op:BinOp0> <rhs:ExprElse> => Node::BinOp(BinOp { lhs: Box::new(lhs), op, rhs: Box::new(rhs) }),
	#[precedence(level="3")] #[assoc(side="left")] <lhs:ExprElse> <op:BinOp1> <rhs:ExprElse> => Node::BinOp(BinOp { lhs: Box::new(lhs), op, rhs: Box::new(rhs) }),
	#[precedence(level="4")] #[assoc(side="left")] <lhs:ExprElse> <op:BinOp2> <rhs:ExprElse> => Node::BinOp(BinOp { lhs: Box::new(lhs), op, rhs: Box::new(rhs) }),
	#[precedence(level="5")] #[assoc(side="left")] <lhs:ExprElse> <op:BinOp3> <rhs:ExprElse> => Node::BinOp(BinOp { lhs: Box::new(lhs), op, rhs: Box::new(rhs) }),
	#[precedence(level="6")] #[assoc(side="left")] <lhs:ExprElse> <op:BinOp4> <rhs:ExprElse> => Node::BinOp(BinOp { lhs: Box::new(lhs), op, rhs: Box::new(rhs) }),
	#[precedence(level="7")]
	Loop<StmtElse> => Node::Loop(<>),
	WhileElse<ExprElse, BlockExpr, ExprElse> => Node::While(<>),
	ForElse<ExprElse, BlockExpr, ExprElse> => Node::For(<>),
	IfElse<ExprElse, BlockExpr, ExprElse> => Node::IfElse(<>),
};

UnaOp: UnaOpKind = {
	"+" => UnaOpKind::Identity,
	"-" => UnaOpKind::Negate,
	"!" => UnaOpKind::Invert,
};
BinOp0: BinOpKind = {
	"*" => BinOpKind::Arith(ArithBinOpKind::Mul),
	"/" => BinOpKind::Arith(ArithBinOpKind::Div),
};
BinOp1: BinOpKind = {
	"+" => BinOpKind::Arith(ArithBinOpKind::Add),
	"-" => BinOpKind::Arith(ArithBinOpKind::Sub),
};
BinOp2: BinOpKind = {
	"==" => BinOpKind::Cmp(CmpBinOpKind::Eq),
	"!=" => BinOpKind::Cmp(CmpBinOpKind::Ne),
	"<" => BinOpKind::Cmp(CmpBinOpKind::Lt),
	"<=" => BinOpKind::Cmp(CmpBinOpKind::Le),
	">" => BinOpKind::Cmp(CmpBinOpKind::Gt),
	">=" => BinOpKind::Cmp(CmpBinOpKind::Ge),
}
BinOp3: BinOpKind = {
	"&&" => BinOpKind::Logic(LogicBinOpKind::And),
};
BinOp4: BinOpKind = {
	"||" => BinOpKind::Logic(LogicBinOpKind::Or),
}

Block: Block = "{" <body:Stmt*> "}" => Block { body, expr: None };
BlockExpr: Block = "{" <body:Stmt*> "||" <expr:Expr> "}" => Block { body, expr: Some(Box::new(expr)) };
Let: Let = {
	"let" <bind:Pat> "=" <expr:Expr> => Let { bind: Box::new(bind), expr: Box::new(expr) },
};
Assign: Assign = {
	//<lhs:Expr> "=" <rhs:Expr> => Assign { lhs: Box::new(lhs), rhs: Box::new(rhs) },
	<lhs:Pat> "=" <rhs:Expr> => Assign { lhs: Box::new(lhs), rhs: Box::new(rhs) },
};
Ret: Return = {
	"ret" <expr:Expr?> => Return { expr: expr.map(|expr| Box::new(expr)) },
};
Break: Break = {
	"break" <expr:Expr?> => Break { expr: expr.map(|expr| Box::new(expr)) },
	"break" <Continue> => Break { expr: Some(Box::new(<>)) },
	"break" <Break> => Break { expr: Some(Box::new(Node::Break(<>))) },
};
Continue: Node = "continue" => Node::Continue;
Unreachable: Node = "unreachable" => Node::Unreachable;

Loop<TBody>: Loop = {
	"loop" <body:TBody> => Loop { body: Box::new(body) },
};

While: While = {
	"while" <cond:Expr> <body:Block> => While {
		cond: Box::new(cond),
		body: Box::new(Node::Block(body)),
		body_else: None,
	},
	"while" <cond:Expr> ":" <body:Stmt> => While {
		cond: Box::new(cond),
		body: Box::new(body),
		body_else: None,
	},
	WhileElse<StmtElse, Block, Stmt>,
};
WhileElse<TBody, TBlock, TElse>: While = {
	"while" <cond:Expr> <body:TBlock> "else" <body_else:TElse> => While {
		cond: Box::new(cond),
		body: Box::new(Node::Block(body)),
		body_else: Some(Box::new(body_else)),
	},
	"while" <cond:Expr> ":" <body:TBody> "else" <body_else:TElse> => While {
		cond: Box::new(cond),
		body: Box::new(body),
		body_else: Some(Box::new(body_else)),
	},
};

For: For = {
	"for" <bind:Pat> "in" <iter:Expr> <body:Block> => For {
		bind: Box::new(bind),
		iter: Box::new(iter),
		body: Box::new(Node::Block(body)),
		body_else: None,
	},
	"for" <bind:Pat> "in" <iter:Expr> ":" <body:Stmt> => For {
		bind: Box::new(bind),
		iter: Box::new(iter),
		body: Box::new(body),
		body_else: None,
	},
	ForElse<StmtElse, Block, Stmt>,
};
ForElse<TBody, TBlock, TElse>: For = {
	"for" <bind:Pat> "in" <iter:Expr> <body:TBlock> "else" <body_else:TElse> => For {
		bind: Box::new(bind),
		iter: Box::new(iter),
		body: Box::new(Node::Block(body)),
		body_else: Some(Box::new(body_else)),
	},
	"for" <bind:Pat> "in" <iter:Expr> ":" <body:TBody> "else" <body_else:TElse> => For {
		bind: Box::new(bind),
		iter: Box::new(iter),
		body: Box::new(body),
		body_else: Some(Box::new(body_else)),
	},
};

If: IfElse = {
	"if" <cond:Expr> <body:Block> => IfElse {
		cond: Box::new(cond),
		body: Box::new(Node::Block(body)),
		body_else: None,
	},
	"if" <cond:Expr> ":" <body:Stmt> => IfElse {
		cond: Box::new(cond),
		body: Box::new(body),
		body_else: None,
	},
	IfElse<StmtElse, Block, Stmt>,
};
IfElse<TBody, TBlock, TElse>: IfElse = {
	"if" <cond:Expr> <body:TBlock> "else" <body_else:TElse> => IfElse {
		cond: Box::new(cond),
		body: Box::new(Node::Block(body)),
		body_else: Some(Box::new(body_else)),
	},
	"if" <cond:Expr> ":" <body:TBody> "else" <body_else:TElse> => IfElse {
		cond: Box::new(cond),
		body: Box::new(body),
		body_else: Some(Box::new(body_else)),
	},
};

Pat: Node = {
	"identifier" => Node::Literal(Literal::Identifier(<>)),
};

extern {
	type Location = usize;
	type Error = LexicalError;

	enum Token {
		";" => Token::Semicolon,
		":" => Token::Colon,
		"," => Token::Comma,
		"." => Token::Dot,

		"(" => Token::LParen,
		")" => Token::RParen,
		"[" => Token::LBracket,
		"]" => Token::RBracket,
		"{" => Token::LBrace,
		"}" => Token::RBrace,

		"+" => Token::Plus,
		"-" => Token::Dash,
		"*" => Token::Star,
		"/" => Token::Slash,
		"%" => Token::Percent,
		"#" => Token::Hash,
		"<<" => Token::LShift,
		">>" => Token::RShift,
		"&" => Token::Ampersand,
		"|" => Token::Bar,

		"=" => Token::Equals,
		"==" => Token::Eq,
		"!=" => Token::Ne,
		"<" => Token::Lt,
		"<=" => Token::Le,
		">" => Token::Gt,
		">=" => Token::Ge,
		"&&" => Token::And,
		"||" => Token::Or,
		"!" => Token::Bang,

		"let" => Token::Let,
		"mut" => Token::Mut,
		"_" => Token::Discard,

		"ret" => Token::Return,
		"break" => Token::Break,
		"continue" => Token::Continue,
		"unreachable" => Token::Unreachable,

		"plex" => Token::Plex,
		"fn" => Token::Fn,
		"pub" => Token::Pub,

		"loop" => Token::Loop,
		"while" => Token::While,
		"for" => Token::For,
		"in" => Token::In,
		"if" => Token::If,
		"else" => Token::Else,
		"match" => Token::Match,

		"true" => Token::True,
		"false" => Token::False,
		"string" => Token::String(<String>),
		"integer" => Token::Integer(<u64>),
		"real" => Token::Real(<u64>),
		"identifier" => Token::Identifier(<String>),
	}
}
