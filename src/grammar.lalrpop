use lalrpop_util::ErrorRecovery;
use crate::lexer::{Token, LexicalError};
use crate::parser::*;

grammar<'err>(errors: &'err mut Vec<ErrorRecovery<usize, Token, AstError>>);

Delimit<T, S>: Vec<T> = {
	<mut v:(<T> S)*> <e:T?> => {
		if let Some(e) = e {
			v.push(e);
		}
		v
	}
};

Tier<Op,NextTier>: Node = {
	<lhs:Tier<Op,NextTier>> <op:Op> <rhs:NextTier> => Node::BinOp(BinOp { lhs: Box::new(lhs), op, rhs: Box::new(rhs) }),
	NextTier
};

pub Top: Node = {
	<body:Body> => Node::Block(Block { <> }),
};
Body = Stmt*;
Stmt: Node = {
	<Let> ";" => Node::Let(<>),
	<Assign> ";" => Node::Assign(<>),
	<Ret> ";" => Node::Return(<>),
	<Break> ";" => Node::Break(<>),
	<Continue> ";",
	<Unreachable> ";",

	Block => Node::Block(<>),
	Loop => Node::Loop(<>),
	While => Node::While(<>),
	For => Node::For(<>),
	IfElse => Node::IfElse(<>),
};
Block: Block = "{" <body:Body> "}" => Block { <> };
Let: Let = {
	"let" <bind:Pat> "=" <expr:Expr> => Let { bind: Box::new(bind), expr: Box::new(expr) },
};
Assign: Assign = {
	//<lhs:Expr> "=" <rhs:Expr> => Assign { lhs: Box::new(lhs), rhs: Box::new(rhs) },
	<lhs:Atom> "=" <rhs:Expr> => Assign { lhs: Box::new(lhs), rhs: Box::new(rhs) },
};
Ret: Return = {
	"ret" <expr:Expr?> => Return { expr: expr.map(|expr| Box::new(expr)) },
};
Break: Break = {
	"break" <expr:Expr?> => Break { expr: expr.map(|expr| Box::new(expr)) },
	"break" <expr:Continue> => Break { expr: Some(Box::new(<>)) },
};
Continue: Node = "continue" => Node::Continue;
Unreachable: Node = "unreachable" => Node::Unreachable;
Loop: Loop = {
	"loop" <body:Expr> => Loop { body: Box::new(body) },
};
While: While = {
	"while" <cond:Expr> <body:Block> <body_else:("else" <Expr>)?> => While {
		cond: Box::new(cond),
		body: Box::new(Node::Block(body)),
		body_else: body_else.map(|body_else| Box::new(body_else)),
	},
	"while" <cond:Expr> ":" <body:Expr> <body_else:("else" <Expr>)?> => While {
		cond: Box::new(cond),
		body: Box::new(body),
		body_else: body_else.map(|body_else| Box::new(body_else)),
	},
};
For: For = {
	"for" <bind:Pat> "in" <iter:Expr> <body:Block> <body_else:("else" <Expr>)?> => For {
		bind: Box::new(bind),
		iter: Box::new(iter),
		body: Box::new(Node::Block(body)),
		body_else: body_else.map(|body_else| Box::new(body_else)),
	},
	"for" <bind:Pat> "in" <iter:Expr> ":" <body:Expr> <body_else:("else" <Expr>)?> => For {
		bind: Box::new(bind),
		iter: Box::new(iter),
		body: Box::new(body),
		body_else: body_else.map(|body_else| Box::new(body_else)),
	},
};
IfElse: IfElse = {
	"if" <cond:Expr> <body:Block> <body_else:("else" <Expr>)?> => IfElse {
		cond: Box::new(cond),
		body: Box::new(Node::Block(body)),
		body_else: body_else.map(|body_else| Box::new(body_else)),
	},
	"if" <cond:Expr> ":" <body:Expr> <body_else:("else" <Expr>)?> => IfElse {
		cond: Box::new(cond),
		body: Box::new(body),
		body_else: body_else.map(|body_else| Box::new(body_else)),
	},
};

Pat: Node = {
	"identifier" => Node::Literal(Literal::Identifier(<>)),
};

Expr: Node = {
	#[precedence(level="0")] Atom,
	#[precedence(level="1")] #[assoc(side="left")] <op:UnaOp> <expr:Expr> => Node::UnaOp(UnaOp { op, expr: Box::new(expr) }),
	#[precedence(level="2")] #[assoc(side="left")] <lhs:Expr> <op:BinOp0> <rhs:Expr> => Node::BinOp(BinOp { lhs: Box::new(lhs), op, rhs: Box::new(rhs) }),
	#[precedence(level="3")] #[assoc(side="left")] <lhs:Expr> <op:BinOp1> <rhs:Expr> => Node::BinOp(BinOp { lhs: Box::new(lhs), op, rhs: Box::new(rhs) }),
	#[precedence(level="4")] #[assoc(side="left")] <lhs:Expr> <op:BinOp2> <rhs:Expr> => Node::BinOp(BinOp { lhs: Box::new(lhs), op, rhs: Box::new(rhs) }),
	#[precedence(level="5")] #[assoc(side="left")] <lhs:Expr> <op:BinOp3> <rhs:Expr> => Node::BinOp(BinOp { lhs: Box::new(lhs), op, rhs: Box::new(rhs) }),
	#[precedence(level="6")] #[assoc(side="left")] <lhs:Expr> <op:BinOp4> <rhs:Expr> => Node::BinOp(BinOp { lhs: Box::new(lhs), op, rhs: Box::new(rhs) }),
};
UnaOp: UnaOpKind = {
	"+" => UnaOpKind::Identity,
	"-" => UnaOpKind::Negate,
	"!" => UnaOpKind::Invert,
};
BinOp0: BinOpKind = {
	"*" => BinOpKind::Arith(ArithBinOpKind::Mul),
	"/" => BinOpKind::Arith(ArithBinOpKind::Div),
};
BinOp1: BinOpKind = {
	"+" => BinOpKind::Arith(ArithBinOpKind::Add),
	"-" => BinOpKind::Arith(ArithBinOpKind::Sub),
};
BinOp2: BinOpKind = {
	"&&" => BinOpKind::Logic(LogicBinOpKind::And),
};
BinOp3: BinOpKind = {
	"||" => BinOpKind::Logic(LogicBinOpKind::Or),
}
BinOp4: BinOpKind = {
	"==" => BinOpKind::Cmp(CmpBinOpKind::Eq),
	"!=" => BinOpKind::Cmp(CmpBinOpKind::Ne),
	"<" => BinOpKind::Cmp(CmpBinOpKind::Lt),
	"<=" => BinOpKind::Cmp(CmpBinOpKind::Le),
	">" => BinOpKind::Cmp(CmpBinOpKind::Gt),
	">=" => BinOpKind::Cmp(CmpBinOpKind::Ge),
}

Atom: Node = {
	Block => Node::Block(<>),
	//Loop => Node::Loop(<>),
	//While => Node::While(<>),
	//For => Node::For(<>),
	//IfElse => Node::IfElse(<>),
	//<Unreachable>,

	Lit => Node::Literal(<>),
	"(" <Expr> ")",

	//! => { errors.push(<>); Node::Error },
};

Lit: Literal = {
	"identifier" => Literal::Identifier(<>),
	"integer" => Literal::Integer(<>),
	// "real" => Literal::Float(<>),
	// "string" => Literal::String(<>),
};

extern {
	type Location = usize;
	type Error = LexicalError;

	enum Token {
		"let" => Token::Let,
		"loop" => Token::Loop,
		"while" => Token::While,
		"for" => Token::For,
		"in" => Token::In,
		"if" => Token::If,
		"else" => Token::Else,
		"match" => Token::Match,

		"ret" => Token::Ret,
		"break" => Token::Break,
		"continue" => Token::Continue,
		"unreachable" => Token::Unreachable,

		// "pub" => Token::Pub,
		// "mut" => Token::Mut,
		// "struct" => Token::Struct,
		// "fn" => Token::Fn,

		"identifier" => Token::Identifier(<String>),
		"integer" => Token::Integer(<u64>),
		"string" => Token::String(<String>),
		
		"(" => Token::LParen,
		")" => Token::RParen,
		"{" => Token::LBrace,
		"}" => Token::RBrace,
		"[" => Token::LBracket,
		"]" => Token::RBracket,

		"=" => Token::Assign,
		";" => Token::Semicolon,
		":" => Token::Colon,
		"," => Token::Comma,
		"." => Token::Dot,

		"==" => Token::Eq,
		"!=" => Token::Ne,
		"<" => Token::Lt,
		"<=" => Token::Le,
		">" => Token::Gt,
		">=" => Token::Ge,

		"+" => Token::Add,
		"-" => Token::Sub,
		"*" => Token::Mul,
		"/" => Token::Div,
		//"%" => Token::Rem,
		"&&" => Token::And,
		"||" => Token::Or,
		"!" => Token::Not,
	}
}
