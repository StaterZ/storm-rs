use std::str::FromStr;
use lalrpop_util::ParseError;
use lalrpop_util::ErrorRecovery;
use crate::ast::*;

grammar<'err>(errors: &'err mut Vec<ErrorRecovery<usize, Token<'input>, AstError>>);

extern {
	type Error = AstError;
}

Delimit<T, S>: Vec<T> = {
	<mut v:(<T> S)*> <e:T?> => {
		if let Some(e) = e {
			v.push(e);
		}
		v
	}
};

Tier<Op,NextTier>: Node = {
	<lhs:Tier<Op,NextTier>> <op:Op> <rhs:NextTier> => Node::BinOp(BinOp { lhs: Box::new(lhs), op, rhs: Box::new(rhs) }),
	NextTier
};

pub Top: Node = {
	<stmts:Body> => Node::Block(Block { <> }),
};
Body = Delimit<Stmt, ";">;
Stmt: Node = {
	Let => Node::Let(<>),
	Assign => Node::Assign(<>),
	Ret => Node::Return(<>),
	Break => Node::Break(<>),
	Continue,

	Block => Node::Block(<>),
	Loop => Node::Loop(<>),
	While => Node::While(<>),
	For => Node::For(<>),
	IfElse => Node::IfElse(<>),
	"unreachable" => Node::Unreachable,
};
Block: Block = "{" <stmts:Body> "}" => Block { <> };
Let: Let = {
	"let" <bind:Pat> "=" <expr:Expr> => Let { bind: Box::new(bind), expr: Box::new(expr) },
};
Assign: Assign = {
	<lhs:Expr> "=" <rhs:Expr> => Assign { lhs: Box::new(lhs), rhs: Box::new(rhs) },
};
Ret: Return = {
	"ret" <expr:Expr?> => Return { expr: expr.map(|expr| Box::new(expr)) },
};
Break: Break = {
	"break" <expr:Expr?> => Break { expr: expr.map(|expr| Box::new(expr)) },
	"break" <expr:Continue> => Break { expr: Some(Box::new(<>)) },
};
Continue: Node = "continue" => Node::Continue;
Loop: Loop = {
	"loop" <body:Expr> => Loop { body: Box::new(body) },
};
While: While = {
	"while" <cond:Expr> <body:Block> <body_else:("else" <Expr>)?> => While {
		cond: Box::new(cond),
		body: Box::new(Node::Block(body)),
		body_else: body_else.map(|body_else| Box::new(body_else)),
	},
	"while" <cond:Expr> ":" <body:Expr> <body_else:("else" <Expr>)?> => While {
		cond: Box::new(cond),
		body: Box::new(body),
		body_else: body_else.map(|body_else| Box::new(body_else)),
	},
};
For: For = {
	"for" <bind:Pat> "in" <iter:Expr> <body:Block> <body_else:("else" <Expr>)?> => For {
		bind: Box::new(bind),
		iter: Box::new(iter),
		body: Box::new(Node::Block(body)),
		body_else: body_else.map(|body_else| Box::new(body_else)),
	},
	"for" <bind:Pat> "in" <iter:Expr> ":" <body:Expr> <body_else:("else" <Expr>)?> => For {
		bind: Box::new(bind),
		iter: Box::new(iter),
		body: Box::new(body),
		body_else: body_else.map(|body_else| Box::new(body_else)),
	},
};
IfElse: IfElse = {
	"if" <cond:Expr> <body_if:Block> <body_else:("else" <Expr>)?> => IfElse {
		cond: Box::new(cond),
		body_if: Box::new(Node::Block(body_if)),
		body_else: body_else.map(|body_else| Box::new(body_else)),
	},
	"if" <cond:Expr> ":" <body_if:Expr> <body_else:("else" <Expr>)?> => IfElse {
		cond: Box::new(cond),
		body_if: Box::new(body_if),
		body_else: body_else.map(|body_else| Box::new(body_else)),
	},
};

Pat: Node = {
	Ident => Node::Literal(Literal::Identifier(<>)),
};

Expr = Tier<BinOp0, Factor>;
Factor = Tier<BinOp1, Term>;
//BinOpLogic: BinOpKind = {
//	"&&" => BinOpKind::(ArithBinOpKind::And),
//	"||" => BinOpKind::Arith(ArithBinOpKind::Or),
//};
BinOp0: BinOpKind = {
	"+" => BinOpKind::Arith(ArithBinOpKind::Add),
	"-" => BinOpKind::Arith(ArithBinOpKind::Sub),
};
BinOp1: BinOpKind = {
	"*" => BinOpKind::Arith(ArithBinOpKind::Mul),
	"/" => BinOpKind::Arith(ArithBinOpKind::Div),
};

Term: Node = {
	Atom,
	<op:UnaOp> <expr:Term> => Node::UnaOp(UnaOp { op, expr: Box::new(expr) }),
};
UnaOp: UnaOpKind = {
	"+" => UnaOpKind::Identity,
	"-" => UnaOpKind::Negate,
};
Atom: Node = {
	Block => Node::Block(<>),
	//Loop => Node::Loop(<>),
	//While => Node::While(<>),
	//For => Node::For(<>),
	//IfElse => Node::IfElse(<>),
	"unreachable" => Node::Unreachable,

	Lit => Node::Literal(<>),
	"(" <Expr> ")",

	//! => { errors.push(<>); Node::Error },
};

Lit: Literal = {
	Int => Literal::Integer(<>),
	// Float => Literal::Float(<>),
	// String => Literal::String(<>),
	Ident => Literal::Identifier(<>),
};

Int: u64 = r"[0-9]+" =>? u64::from_str(<>).map_err(|e| ParseError::User {
	error: AstError::BadNumber(e)
});

Ident: String = r"[\p{XID_Start}_]\p{XID_Continue}*" => <>.to_string();

//extern {
//	type Location = usize;
//	type Error = LexicalError;
//
//	pub enum Token {
//		Let,
//		Loop,
//		While,
//		For,
//		If,
//		Else,
//		// Match,
//
//		Ret,
//		Break,
//		Continue,
//		Unreachable,
//
//		// Pub,
//		// Mut,
//		// Struct,
//		// Fn,
//
//		Identifier(String),
//		Integer(u128),
//		String(String),
//		
//		LParen,
//		RParen,
//		LBrace,
//		RBrace,
//		LBracket,
//		RBracket,
//
//		Assign,
//		Semicolon,
//		Colon,
//		Coma,
//		Dot,
//
//		Lt,
//		Le,
//		Gt,
//		Ge,
//		Eq,
//		Ne,
//
//		Add,
//		Sub,
//		Mul,
//		Div,
//		// Rem,
//		And,
//		Or,
//		Not,
//	}
//}
